<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Fast Math</title>

  <style>
    :root{
      --bg:#0e0f12; --text:#ffffff; --muted:#a8b0bb; --accent:#1e90ff; --accent2:#00bfff; --panel:#161a20; --input:#15181d;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial;
      text-align:center
    }
    h1{margin:18px 0 6px;color:var(--accent)}
    #version {
      color: var(--accent);
      font-size: 0.75em;
      margin-top: -6px;
    }

    /* LOGIN */
    #login-screen{
      min-height:40vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:10px
    }
    #loginBtn{
      background:#0078d4;
      border:none;
      color:#fff;
      border-radius:8px;
      padding:12px 20px;
      font-size:16px;
      cursor:pointer
    }
    #loginBtn:hover{background:#005ea6}
    #loginStatus{color:#ff8a8a;font-size:13px}

    /* EMPEROR SCREEN */
    #emperor-screen{
      display:none;
      min-height:50vh;
      padding-top:40px;
    }
    .emp-line{
      font-size:28px;
      font-weight:600;
      margin:8px 0;
    }
    .emp-name{
      font-size:42px;
      font-weight:900;
      margin:12px 0 22px 0;
      background:linear-gradient(
        90deg,
        red,
        orange,
        yellow,
        green,
        cyan,
        blue,
        violet,
        red
      );
      background-size:400%;
      -webkit-background-clip:text;
      color:transparent;
      animation:rainbowScroll 6s linear infinite;
    }
    .emp-score{
      font-size:42px;
      font-weight:900;
      margin:10px 0 10px 0;
      background:linear-gradient(
        90deg,
        red,
        orange,
        yellow,
        green,
        cyan,
        blue,
        violet,
        red
      );
      background-size:400%;
      -webkit-background-clip:text;
      color:transparent;
      animation:rainbowScroll 6s linear infinite;
    }
    @keyframes rainbowScroll{
      0%{background-position:0%}
      100%{background-position:400%}
    }
    #playBtn{
      margin-top:25px;
      background:var(--accent);
      padding:14px 24px;
      border:none;
      border-radius:10px;
      color:white;
      font-size:20px;
      cursor:pointer;
    }
    #playBtn:hover{
      filter:brightness(1.1);
    }

    /* GAME */
    #game-container{
      display:none;
      max-width:900px;
      margin:0 auto;
      padding:10px 16px
    }
    #question{
      font-size:48px;
      font-weight:700;
      margin-top:80px;
      margin-bottom:30px;
      min-height:1.2em;
      transition:transform .05s
    }
    #timerBar{
      width:70%;
      height:30px;
      background:#20242b;
      border-radius:15px;
      margin:30px auto 30px;
      overflow:hidden;
      box-shadow:0 0 10px #1e90ff55
    }
    #timerFill{
      height:100%;
      background:linear-gradient(90deg, var(--accent), var(--accent2));
      width:100%
    }
    #answer{
      font-size:32px;
      padding:10px;
      border-radius:10px;
      border:2px solid var(--accent);
      width:140px;
      background:var(--input);
      color:#fff;
      text-align:center;
      outline:none;
      box-shadow:0 0 10px #1e90ff33;
      margin-bottom:16px
    }
    #answer:focus{
      border-color:var(--accent2);
      box-shadow:0 0 15px #00bfff55
    }
    #stage-info{
      margin-top:6px;
      font-size:18px;
      color:#c9d2db
    }

    /* END SCREEN */
    #end-screen{
      display:none;
      text-align:center;
      margin-top:60px;
      color:#fff
    }
    #end-screen h3{
      color:#ff4d4d;
      font-size:28px;
      margin:4px 0 10px
    }
    #end-screen p{
      margin:6px 0;
      font-size:18px
    }
    #end-screen button{
      background:var(--accent);
      border:none;
      color:#fff;
      padding:10px 20px;
      font-size:16px;
      border-radius:8px;
      margin:10px;
      cursor:pointer;
      transition:filter .2s
    }
    #end-screen button:hover{filter:brightness(1.05)}
    #session-id{color:#99a6b4;font-size:14px}
    #saved-status{color:#7fdca2;font-size:14px}

    /* LEADERBOARD */
    #leaderboardContainer{
      display:none;
      margin:40px auto 20px;
      max-width:800px;
      text-align:center;
      opacity:0;
      transition:opacity .3s
    }
    #leaderboardContainer.show{opacity:1}
    #leaderboardStatus{color:#cfd6de;font-size:14px}
    #leaderboardContainer table{
      width:100%;
      border-collapse:collapse;
      margin-top:12px
    }
    #leaderboardContainer th,#leaderboardContainer td{
      padding:10px;
      border-bottom:1px solid #2a2f37;
      text-align:center
    }
    #leaderboardContainer th{
      color:var(--accent);
      font-weight:600;
      border-bottom:2px solid #1e90ff33
    }
    #leaderboardContainer td{color:#e6e9ee}
    #leaderboardContainer tr:hover td{background:#1e90ff22}

    #leaderboardButtons{
      margin-top:10px;
      display:flex;
      justify-content:center;
      gap:8px;
    }
    #leaderboardButtons button{
      background:var(--accent);
      border:none;
      color:#fff;
      padding:6px 14px;
      border-radius:8px;
      cursor:pointer;
      font-size:14px;
    }
    #leaderboardButtons button:hover{
      filter:brightness(1.05);
    }
  </style>

  <!-- Supabase JS (v2) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <h1>Fusion Fast Math</h1>
  <p id="version"></p>

  <!-- Sign-In Screen -->
  <div id="login-screen">
    <p class="note" style="color:#c9d2db">
      Please sign in with your Microsoft account to continue.
    </p>
    <button id="loginBtn">Sign in with Microsoft</button>
    <div id="loginStatus"></div>
  </div>

  <!-- Emperor Screen -->
  <div id="emperor-screen">
    <h2 class="emp-line">The Current Emperor</h2>
    <h2 class="emp-line">Of Multiplication Is:</h2>
    <h1 id="emperorName" class="emp-name">—</h1>

    <h2 class="emp-line">With A Score Of:</h2>
    <h1 id="emperorScore" class="emp-score">—</h1>

    <button id="playBtn">Play</button>
  </div>

  <!-- Game -->
  <div id="game-container">
    <div id="question"></div>
    <div id="timerBar"><div id="timerFill"></div></div>
    <input id="answer" type="text" autocomplete="off" inputmode="numeric" placeholder="?" />
    <div id="stage-info"></div>
  </div>

  <!-- End Screen -->
  <div id="end-screen">
    <h3>Game Over</h3>

    <p id="end-questions">Questions answered: —</p>
    <p id="end-penalty">Total penalty time: — s</p>
    <p id="end-total">Total time: — s (<span id="end-with-penalty">—</span> s with penalties)</p>
    <p id="end-avg">Avg time/question: — s (<span id="end-avg-with-penalty">—</span> s with penalties)</p>

    <p id="session-id"></p>
    <p id="saved-status"></p>

    <button id="restartBtn">Restart</button>

    <div id="leaderboardButtons">
      <button id="viewAllBtn">Everyone</button>
      <button id="viewStudentsBtn">Students</button>
      <button id="viewTeachersBtn">Teachers</button>
    </div>

    <div id="leaderboardContainer">
      <p id="leaderboardStatus"></p>
      <table>
        <thead>
          <tr>
            <th>#</th><th>Player</th><th>Questions</th><th>Time (s)</th><th>Date</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Firebase Auth + Supabase Backend + Game -->
  <script type="module">

  // Game version
  const GAME_VERSION = "1.0.33";

  async function upsertLeaderboardEntry({
    playerName,
    questionsAnswered,
    totalTime,
    penaltyTime,
    stageReached,
    isTeacher,
    isStudent,
    versionNumber
  }) {
    const nowIso = new Date().toISOString();

    // 1. Get existing leaderboard entry for this player
    const { data: existing, error: fetchErr } = await supabase
      .from("leaderboard")
      .select("*")
      .eq("player_name", playerName)
      .maybeSingle();

    if (fetchErr) {
      console.error("Leaderboard fetch error:", fetchErr);
      return;
    }

    // 2. If none exists → INSERT directly
    if (!existing) {
      const { error: insertErr } = await supabase
        .from("leaderboard")
        .insert({
          player_name: playerName,
          stage_reached: stageReached,
          questions_answered: questionsAnswered,
          total_time_seconds: totalTime,
          penalty_time_seconds: penaltyTime,
          date_added: nowIso,
          is_teacher: isTeacher,
          is_student: isStudent,
          version_number: versionNumber
        });

      if (insertErr) console.error("Leaderboard insert failed:", insertErr);
      return;
    }

    // 3. Compare performance vs. existing row
    const betterQuestions = questionsAnswered > existing.questions_answered;
    const sameQuestions = questionsAnswered === existing.questions_answered;
    const fasterTime = totalTime < existing.total_time_seconds;

    const shouldUpdate = betterQuestions || (sameQuestions && fasterTime);

    if (!shouldUpdate) {
      console.log("Leaderboard: new score is NOT better, skipping update.");
      return;
    }

    // 4. Update existing row
    const { error: updateErr } = await supabase
      .from("leaderboard")
      .update({
        stage_reached: stageReached,
        questions_answered: questionsAnswered,
        total_time_seconds: totalTime,
        penalty_time_seconds: penaltyTime,
        date_added: nowIso,
        version_number: versionNumber
      })
      .eq("leaderboard_id", existing.leaderboard_id);

    if (updateErr) console.error("Leaderboard update failed:", updateErr);
  }

  /* ===================== Supabase Config ===================== */
  const SUPABASE_URL = "https://jfjlznxvofhjjlommdrd.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_bSFpnR01TewY44SI8mLuLA_aX3bF3Lk";

  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  async function recordUserLogin(email, name) {
    const nowIso = new Date().toISOString();

    // 1. First check if a user with this name already exists
    const { data: existingUser, error: findErr } = await supabase
      .from("users")
      .select("*")
      .eq("name", name)
      .maybeSingle();

    if (findErr) {
      console.error("User lookup error:", findErr);
    }

    let userId = null;

    if (existingUser) {
      // Existing user found — update if needed
      userId = existingUser.user_id;

      const updatedEmail = existingUser.email || email;  // only overwrite email if NULL

      const { error: updateErr } = await supabase
        .from("users")
        .update({
          email: updatedEmail,
          last_login_at: nowIso
        })
        .eq("user_id", userId);

      if (updateErr) {
        console.error("User update failed:", updateErr);
      }
    } else {
      // No user row existed — create new
      const { data: inserted, error: insertErr } = await supabase
        .from("users")
        .insert({
          name,
          email,
          last_login_at: nowIso
        })
        .select()
        .single();

      if (insertErr) {
        console.error("User insert failed:", insertErr);
      } else {
        userId = inserted.user_id;
      }
    }

    // 2. Always add a record to the logins table
    if (userId !== null) {
      const { error: loginErr } = await supabase
        .from("logins")
        .insert({
          user_id: userId,
          name,
          login_at: nowIso
        });

      if (loginErr) {
        console.error("Login insert failed:", loginErr);
      }
    }

    return userId;
  }

  /* ===================== Firebase SDKs (Auth only) ===================== */
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
  import {
    getAuth, OAuthProvider, signInWithPopup,
    setPersistence, browserLocalPersistence, onAuthStateChanged
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";

  /* ===================== Firebase Config ===================== */
  const firebaseConfig = {
    apiKey: "AIzaSyBUaOrUckCuTrc9MHB9jCF4TUsx-hWFC7g",
    authDomain: "ironmath-1263b.firebaseapp.com",
    projectId: "ironmath-1263b",
    storageBucket: "ironmath-1263b.firebasestorage.app",
    messagingSenderId: "729878130193",
    appId: "1:729878130193:web:f4d447b552e4f955f80bb0",
    measurementId: "G-0VCM7C1HPC"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const provider = new OAuthProvider("microsoft.com");
  await setPersistence(auth, browserLocalPersistence);

  const versionElement = document.getElementById("version");
  if (versionElement) {
    versionElement.textContent = `v${GAME_VERSION}`;
  }

  /* ===================== DOM ===================== */
  const loginScreen = document.getElementById("login-screen");
  const loginBtn = document.getElementById("loginBtn");
  const loginStatus = document.getElementById("loginStatus");

  const emperorScreen = document.getElementById("emperor-screen");
  const emperorName = document.getElementById("emperorName");
  const emperorScore = document.getElementById("emperorScore");
  const playBtn = document.getElementById("playBtn");

  const gameContainer = document.getElementById("game-container");
  const endScreen = document.getElementById("end-screen");
  const questionEl = document.getElementById("question");
  const answerEl = document.getElementById("answer");
  const stageInfo = document.getElementById("stage-info");
  const timerFill = document.getElementById("timerFill");
  const restartBtn = document.getElementById("restartBtn");
  const viewAllBtn = document.getElementById("viewAllBtn");
  const viewStudentsBtn = document.getElementById("viewStudentsBtn");
  const viewTeachersBtn = document.getElementById("viewTeachersBtn");
  const lbWrap = document.getElementById("leaderboardContainer");
  const lbStatus = document.getElementById("leaderboardStatus");
  const lbBody = document.querySelector("#leaderboardContainer tbody");

  /* ===================== Auth Flow ===================== */
  function parseEmailToName(email){
    if(!email) return "Player";
    const local = email.split("@")[0];
    const parts = local.split(/[._-]+/).filter(Boolean);
    if(parts.length >= 2) return parts.map(cap).join(" ");
    return cap(local);
  }
  const cap = s => s ? s.charAt(0).toUpperCase() + s.slice(1) : s;
  let playerName = "Player";

  let isTeacher = false;
  let isStudent = false;

  async function showEmperorAfterLogin(email) {
    const userId = await recordUserLogin(email, playerName);
    window.currentUserId = userId;

    loginScreen.style.display = "none";
    endScreen.style.display = "none";
    gameContainer.style.display = "none";

    await fetchAndCacheLeaderboard();     // fill cachedLeaderboardData + cachedEmperorData
    showEmperor();
  }

  onAuthStateChanged(auth, async (user) => {
    if (user) {
      playerName = user.displayName || parseEmailToName(user.email);
      const email = user.email?.toLowerCase() || "";

      if (email.endsWith("@fusionacademy.com")) {
        isTeacher = true;
        isStudent = false;
      } else if (email.endsWith("@fusionacademy.me")) {
        isStudent = true;
        isTeacher = false;
      } else {
        isTeacher = false;
        isStudent = false;
      }

      await showEmperorAfterLogin(email);
    } else {
      emperorScreen.style.display = "none";
      gameContainer.style.display = "none";
      endScreen.style.display = "none";
      loginScreen.style.display = "flex";
    }
  });

  loginBtn.addEventListener("click", async ()=>{
    try{
      const result = await signInWithPopup(auth, provider);
      const u = result.user;
      playerName = u.displayName || parseEmailToName(u.email);

      const email = u.email?.toLowerCase() || "";
      if (email.endsWith("@fusionacademy.com")) {
        isTeacher = true;
        isStudent = false;
      } else if (email.endsWith("@fusionacademy.me")) {
        isStudent = true;
        isTeacher = false;
      } else {
        isTeacher = false;
        isStudent = false;
      }

      await showEmperorAfterLogin(email);
    }catch(e){
      console.error("Sign-in error:", e);
      loginStatus.textContent = "Sign-in failed: " + (e?.message || e);
    }
  });

  /* ===================== Game Settings ===================== */
  const SIGMA_SCALE = 6;       // normal distribution width across product range
  const STRETCH_MULT = 0.5;    // one factor may stretch up to stage*(1+STRETCH_MULT)
  const WEIGHT_DECAY = 0.88;   // repeat product decay factor
  const WEIGHT_STRENGTH = 4;   // how strongly repeats are penalized
  const START_STAGE = 8;
  const TIMER_SECONDS = 10;
  const DUPLICATE_PROTECTION = 25;
  const PENALTY_MULT = 2;      // per-digit penalty multiplier (1x,2x,4x...) per question

  /* ===================== Game State ===================== */
  let sessionId = buildSessionID(playerName);
  let stage = START_STAGE;
  let questionCount = 0;
  let correctCount = 0;
  let totalTimeTrue = 0;
  let penaltySeconds = 0;
  let productWeights = {};
  let recentAnswers = [];
  let current = null;
  let timeLeft = TIMER_SECONDS;
  let rafId = 0;
  let qStartTs = 0;
  let runStartTs = 0;
  let mistakesThisQuestion = 0;
  let loggedThisQuestion = false;

  // runData holds per-question results for this session
  let runData = { sessionID: "", results: [] };

  /* ===================== Helpers ===================== */
  function randn(){
    let u=0,v=0;
    while(u===0)u=Math.random();
    while(v===0)v=Math.random();
    return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
  }
  function sampleTrunc(minV,maxV,mu,sigma){
    if(sigma<=0||!isFinite(sigma)) return Math.min(Math.max(mu,minV),maxV);
    for(let i=0;i<40;i++){
      const x=mu+sigma*randn();
      if(x>=minV && x<=maxV) return x;
    }
    return Math.min(Math.max(mu,minV),maxV);
  }
  function buildPairs(stage){
    const maxF = Math.floor(stage*(1+STRETCH_MULT));
    const out=[];
    for(let a=1;a<=maxF;a++){
      for(let b=1;b<=maxF;b++){
        if(a>stage && b>stage) continue; // allow stretching on only one factor
        out.push([a,b]);
      }
    }
    return out;
  }
  function choosePair(pairs){
    let minP=Infinity,maxP=-Infinity;
    const prods=new Array(pairs.length);
    for(let i=0;i<pairs.length;i++){
      const p=pairs[i][0]*pairs[i][1];
      prods[i]=p;
      if(p<minP)minP=p;
      if(p>maxP)maxP=p;
    }
    const mu=(minP+maxP)/2;
    const sigma=Math.max(1e-6,(maxP-minP)/SIGMA_SCALE);
    const target=sampleTrunc(minP,maxP,mu,sigma);

    let bestIdx=-1,bestScore=Infinity,safety=0;
    while(safety++<500){
      for(let i=0;i<pairs.length;i++){
        const p=prods[i];
        if(recentAnswers.includes(p)) continue;
        const dist=Math.abs(p-target);
        const w=(productWeights[p]||0);
        const score = dist * (1 + WEIGHT_STRENGTH*w);
        if(score<bestScore){ bestScore=score; bestIdx=i; }
      }
      if(bestIdx!==-1) break;
      // If everything excluded by recent list, relax by popping oldest
      recentAnswers.shift();
    }
    const [a,b]=pairs[bestIdx];
    return {a,b,prod:a*b};
  }
  function decayWeightsAndBump(prod){
    for(const k in productWeights){
      productWeights[k]*=WEIGHT_DECAY;
      if(productWeights[k] < 1e-4) delete productWeights[k];
    }
    productWeights[prod]=(productWeights[prod]||0)+1;
  }
  function shake(el, mult=1){
    const urgency = 1 - (timeLeft/TIMER_SECONDS);
    const dur = 0.3 + 0.2*urgency;
    const base = 8;
    const mag = base * (1 + 2*urgency) * (1 + 0.3*(mult-1));
    const t0 = performance.now();
    (function step(){
      const dt = performance.now()-t0;
      if(dt < dur*1000){
        const k = 1 - dt/(dur*1000);
        const vertBias = 0.5 + 1.5*urgency;
        const dx=(Math.random()*2-1)*mag*k;
        const dy=(Math.random()*2-1)*mag*k*vertBias;
        el.style.transform=`translate(${dx}px,${dy}px)`;
        requestAnimationFrame(step);
      }else{
        el.style.transform='translate(0,0)';
      }
    })();
  }

  function buildSessionID(playerName) {
    const parts = (playerName || "Player").trim().split(/\s+/);
    const first = parts[0] || "Player";
    const last = parts[1] || "";

    // Get MST (UTC−7)
    const now = new Date();
    const utcMs = now.getTime() + now.getTimezoneOffset() * 60000;
    the mst = new Date(utcMs - 7 * 60 * 60000);

    const mm = String(mst.getMonth() + 1).padStart(2, "0");
    const dd = String(mst.getDate()).padStart(2, "0");
    const yyyy = mst.getFullYear();
    const hh = String(mst.getHours()).padStart(2, "0");
    const min = String(mst.getMinutes()).padStart(2, "0");

    return `${first} ${last} ${mm}-${dd}-${yyyy} ${hh}:${min}`;
  }

  function resetRunState() {
    sessionId = buildSessionID(playerName);
    runData = { sessionID: sessionId, results: [] };
    stage = START_STAGE;
    questionCount = 0;
    correctCount = 0;
    totalTimeTrue = 0;
    penaltySeconds = 0;
    productWeights = {};
    recentAnswers = [];
    mistakesThisQuestion = 0;
    loggedThisQuestion = false;
    timeLeft = TIMER_SECONDS;
    cancelAnimationFrame(rafId);
  }

  /* ===================== Game Flow ===================== */
  function startGame(){
    resetRunState();
    runStartTs = performance.now();
    gameContainer.style.display = "block";
    nextQuestion();
  }

  playBtn.addEventListener("click", () => {
    emperorScreen.style.display = "none";
    endScreen.style.display = "none";
    startGame();
  });

  function nextQuestion(){
    const pairs = buildPairs(stage);
    let q; let guard=0;
    do{
      q = choosePair(pairs);
      guard++; if(guard>1000) break;
    }while(recentAnswers.includes(q.prod));
    recentAnswers.push(q.prod);
    if(recentAnswers.length > DUPLICATE_PROTECTION) recentAnswers.shift();
    current = q;
    mistakesThisQuestion = 0;
    loggedThisQuestion = false;

    questionEl.textContent = `${q.a} × ${q.b}`;
    answerEl.value = "";
    answerEl.focus();
    stageInfo.textContent = `Stage ${stage}`;

    let penaltySecondsThisRound = 0;
    timeLeft = TIMER_SECONDS;
    qStartTs = performance.now();
    timerFill.style.width = "100%";
    cancelAnimationFrame(rafId);

    const tick = () => {
      const elapsed = (performance.now() - qStartTs) / 1000;
      const remaining = TIMER_SECONDS - elapsed - penaltySecondsThisRound;
      timeLeft = Math.max(0, remaining);

      const pct = Math.max(0, Math.min(1, timeLeft / TIMER_SECONDS));
      timerFill.style.width = (pct * 100) + "%";

      if (timeLeft <= 0) {
        const trueT = (performance.now() - qStartTs) / 1000;
        totalTimeTrue += trueT;
        runData.results.push({
          a: current.a,
          b: current.b,
          stage,
          timeTaken: (performance.now() - qStartTs) / 1000,
          mistakes: mistakesThisQuestion,
          success: false
        });
        return gameOver();
      }
      rafId = requestAnimationFrame(tick);
    };
    rafId = requestAnimationFrame(tick);

    answerEl.oninput = (e)=>{
      if(!current) return;
      const val = e.target.value.trim();
      if(val === "") return;
      const correctStr = String(current.prod);

      if(val === correctStr){
        const trueT = (performance.now()-qStartTs)/1000;
        totalTimeTrue += trueT;
        correctCount++;
        questionCount++;
        runData.results.push({
          a: current.a,
          b: current.b,
          stage,
          timeTaken: (performance.now() - qStartTs) / 1000,
          mistakes: mistakesThisQuestion,
          success: true
        });
        decayWeightsAndBump(current.prod);
        const stepSize = 2*stage - 1;
        if(questionCount >= stepSize*(stage-START_STAGE+1)) stage++;
        current = null;
        return nextQuestion();
      }

      if(!correctStr.startsWith(val)){
        const avgModifiedSoFar = (totalTimeTrue + penaltySeconds) / Math.max(correctCount, 1) || 2.0;
        const penalty = avgModifiedSoFar * Math.pow(PENALTY_MULT, mistakesThisQuestion);
        mistakesThisQuestion++;
        penaltySeconds += penalty;
        penaltySecondsThisRound += penalty;

        const remaining = TIMER_SECONDS - ((performance.now() - qStartTs) / 1000) - penaltySecondsThisRound;
        timeLeft = Math.max(0, remaining);
        const pct = Math.max(0, Math.min(1, timeLeft / TIMER_SECONDS));
        timerFill.style.width = (pct * 100) + "%";

        e.target.value = val.slice(0, -1);
        shake(questionEl, mistakesThisQuestion);

        if (remaining <= 0) {
          runData.results.push({
            a: current.a,
            b: current.b,
            stage,
            timeTaken: (performance.now() - qStartTs) / 1000,
            mistakes: mistakesThisQuestion,
            success: false
          });
          return gameOver();
        }
      }
    };
  }

  function gameOver(){
    cancelAnimationFrame(rafId);
    current = null;
    gameContainer.style.display = "none";
    endScreen.style.display = "block";

    lbWrap.style.display = "block";
    lbWrap.classList.add("show");
    lbStatus.textContent = "Loading leaderboard...";
    loadLeaderboard("all", true); // default filter

    const totalTrue = totalTimeTrue;
    const totalWithPen = totalTimeTrue + penaltySeconds;
    const avgTrue = totalTrue / Math.max(correctCount,1);
    const avgPen = totalWithPen / Math.max(correctCount,1);

    document.getElementById("end-questions").textContent = `Questions answered: ${correctCount}`;
    document.getElementById("end-penalty").textContent = `Total penalty time: ${penaltySeconds.toFixed(2)} s`;
    document.getElementById("end-total").innerHTML =
      `Total time: ${totalTrue.toFixed(2)} s (<span id="end-with-penalty">${totalWithPen.toFixed(2)}</span> s with penalties)`;
    document.getElementById("end-avg").innerHTML =
      `Avg time/question: ${avgTrue.toFixed(2)} s (<span id="end-avg-with-penalty">${avgPen.toFixed(2)}</span> s with penalties)`;

    uploadSession(totalTrue);
  }

  restartBtn.addEventListener("click", ()=>{
    endScreen.style.display = "none";
    // Show emperor screen again (with potentially updated emperor)
    showEmperor();
  });

  /* ===================== Supabase Uploads + Leaderboard ===================== */

  async function uploadSession(totalTrue) {
    try {
      const now = new Date();
      const createdIso = now.toISOString();
      const totalWithPen = totalTrue + penaltySeconds;

      // 1) Insert session, get numeric session_id
      const { data: sessionRows, error: sessionError } = await supabase
        .from("sessions")
        .insert({
          user_id: window.currentUserId || null,
          name: playerName,
          questions_answered: correctCount,
          true_time_seconds: totalTrue,
          penalty_time_seconds: penaltySeconds,
          total_time_seconds: totalWithPen,
          stage_reached: stage,
          created_at: createdIso,
          version_number: GAME_VERSION
        })
        .select()
        .single();

      if (sessionError) throw sessionError;
      const sessionNumericId = sessionRows.session_id;

      // 2) Insert questions (answers array)
      const questionsPayload = runData.results.map(q => ({
        session_id: sessionNumericId,
        a: q.a,
        b: q.b,
        time_taken: q.timeTaken,
        mistakes: q.mistakes,
        success: q.success,
        date_added: createdIso,
        player_name: playerName,
        version_number: GAME_VERSION
      }));

      if (questionsPayload.length > 0) {
        const { error: qError } = await supabase
          .from("questions")
          .insert(questionsPayload);
        if (qError) {
          console.error("Question insert error:", qError);
        }
      }

      // 3) Upsert leaderboard summary (best score only)
      await upsertLeaderboardEntry({
        playerName,
        questionsAnswered: correctCount,
        totalTime: totalWithPen,
        penaltyTime: penaltySeconds,
        stageReached: stage,
        isTeacher,
        isStudent,
        versionNumber: GAME_VERSION
      });

      // 4) Update local cache in camelCase form
      const cacheEntry = {
        playerName,
        stageReached: stage,
        questionsAnswered: correctCount,
        totalTime: totalWithPen,
        penaltyTime: penaltySeconds,
        dateAdded: now.getTime(),
        isTeacher,
        isStudent
      };

      updateCachedLeaderboardWithNewScore(cacheEntry);
      document.getElementById("saved-status").textContent = "Saved ✓";

    } catch (e) {
      console.error("Upload failed", e);
      const s = document.getElementById("saved-status");
      s.textContent = "Upload failed";
      s.style.color = "#ff8a8a";
    }
  }

  function showLeaderboard(filteredType = "all") {
    const showing = lbWrap.classList.toggle("show");
    lbWrap.style.display = showing ? "block" : "none";
    if (showing) {
      loadLeaderboard(filteredType);
    }
  }

  viewAllBtn.addEventListener("click", () =>
    renderLeaderboard(applyLeaderboardFilter(cachedLeaderboardData || [], "all"))
  );
  viewStudentsBtn.addEventListener("click", () =>
    renderLeaderboard(applyLeaderboardFilter(cachedLeaderboardData || [], "students"))
  );
  viewTeachersBtn.addEventListener("click", () =>
    renderLeaderboard(applyLeaderboardFilter(cachedLeaderboardData || [], "teachers"))
  );

  // Caching variables
  let cachedLeaderboardData = null;
  let cachedEmperorData = null;
  let lastLeaderboardFetchTime = 0;
  const LEADERBOARD_CACHE_DURATION = 60000; // 60 seconds

  function updateCachedLeaderboardWithNewScore(newEntry) {
    if (!newEntry?.playerName) return;

    const key = (newEntry.playerName || "").trim().toLowerCase();
    if (!cachedLeaderboardData) cachedLeaderboardData = [];

    const existingIndex = cachedLeaderboardData.findIndex(
      d => (d.playerName || "").trim().toLowerCase() === key
    );

    if (existingIndex !== -1) {
      const old = cachedLeaderboardData[existingIndex];
      const isBetter =
        newEntry.questionsAnswered > (old.questionsAnswered ?? 0) ||
        (newEntry.questionsAnswered === old.questionsAnswered &&
          newEntry.totalTime < (old.totalTime ?? Infinity));

      if (isBetter) {
        cachedLeaderboardData[existingIndex] = newEntry;
      }
    } else {
      cachedLeaderboardData.push(newEntry);
    }

    cachedLeaderboardData.sort((a, b) => {
      if (b.questionsAnswered === a.questionsAnswered)
        return a.totalTime - b.totalTime;
      return b.questionsAnswered - a.questionsAnswered;
    });

    // Refresh emperor cache as "students only"
    cachedEmperorData = cachedLeaderboardData.filter(d => d.isStudent === true);

    // Default re-render with "all" filter
    renderLeaderboard(applyLeaderboardFilter(cachedLeaderboardData, "all"));
  }

  async function fetchAndCacheLeaderboard(forceRefresh = false) {
    const now = Date.now();
    if (!forceRefresh &&
        cachedLeaderboardData &&
        (now - lastLeaderboardFetchTime < LEADERBOARD_CACHE_DURATION)) {
      return;
    }

    const { data, error } = await supabase
      .from("leaderboard")
      .select("*")
      .order("questions_answered", { ascending: false })
      .order("total_time_seconds", { ascending: true })
      .limit(500);

    if (error) throw error;

    const rows = data || [];
    const normalized = rows
      .filter(r => !!r.player_name)
      .map(r => ({
        playerName: r.player_name,
        questionsAnswered: r.questions_answered ?? 0,
        totalTime: r.total_time_seconds ?? 0,
        penaltyTime: r.penalty_time_seconds ?? 0,
        dateAdded: r.date_added ? new Date(r.date_added).getTime() : null,
        isTeacher: r.is_teacher ?? false,
        isStudent: r.is_student ?? false,
        stageReached: r.stage_reached ?? null
      }));

    const grouped = {};
    for (const d of normalized) {
      const key = (d.playerName || "").trim().toLowerCase();
      if (!grouped[key]) grouped[key] = [];
      grouped[key].push(d);
    }

    const best = Object.values(grouped).map(list =>
      list.sort((a, b) => {
        if (b.questionsAnswered === a.questionsAnswered)
          return a.totalTime - b.totalTime;
        return b.questionsAnswered - a.questionsAnswered;
      })[0]
    );

    best.sort((a, b) => {
      if (b.questionsAnswered === a.questionsAnswered)
        return a.totalTime - b.totalTime;
      return b.questionsAnswered - a.questionsAnswered;
    });

    cachedLeaderboardData = best;
    cachedEmperorData = best.filter(d => d.isStudent === true);
    lastLeaderboardFetchTime = now;
  }

  async function loadLeaderboard(filterType = "all", forceRefresh = false) {
    try {
      lbStatus.textContent = "Loading leaderboard...";

      await fetchAndCacheLeaderboard(forceRefresh);

      renderLeaderboard(applyLeaderboardFilter(cachedLeaderboardData || [], filterType));
      lbStatus.textContent = "";
    } catch (e) {
      console.error(e);
      lbStatus.textContent = "Failed to load leaderboard: " + (e?.message || e);
    }
  }

  function applyLeaderboardFilter(data, filterType) {
    if (filterType === "students") {
      return data.filter(d => d.isStudent === true);
    } else if (filterType === "teachers") {
      return data.filter(d => d.isTeacher === true);
    }
    return data;
  }

  function renderLeaderboard(data) {
    lbBody.innerHTML = "";
    let rank = 1;
    for (const d of data.slice(0, 100)) {
      const date = d.dateAdded ? new Date(d.dateAdded) : null;
      const mm = date ? String(date.getMonth() + 1).padStart(2, "0") : "--";
      const dd = date ? String(date.getDate()).padStart(2, "0") : "--";
      const yyyy = date ? date.getFullYear() : "----";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${rank++}</td>
        <td>${escapeHtml(d.playerName || "???")}</td>
        <td>${d.questionsAnswered ?? "?"}</td>
        <td>${(d.totalTime ?? 0).toFixed(2)}</td>
        <td>${mm}/${dd}/${yyyy}</td>
      `;
      lbBody.appendChild(tr);
    }
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
  }

  function showEmperor() {
    const top = cachedEmperorData?.[0];
    if (top) {
      emperorName.textContent = top.playerName;
      emperorScore.textContent = `${top.questionsAnswered} Correct`;
    } else {
      emperorName.textContent = "—";
      emperorScore.textContent = "—";
    }

    emperorScreen.style.display = "block";
    gameContainer.style.display = "none";
  }

  </script>
</body>
</html>
